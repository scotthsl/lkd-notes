# 内核同步方法总结

## 原子操作

1. 内核提供两组原子操作接口，一组针对整型，一组针对位操作。
2. 原子性确保指令执行期间不被打断，要么全部执行完，要么根本不执行。
3. 能使用原子操作时，就尽量不使用复杂的加锁机制。



## 自旋锁

1. 最多只能被一个可执行线程持有。任意时间，自旋锁都可以防止多于一个执行线程同时进入临界区。另一个等带持有锁的线程只能原地自旋（不能睡眠），空耗CPU时间，所以自旋锁不应该被长时间持有。

2. 持有自旋锁的时间最好小于2次进程上下文切换的时间。信号量导致的进程睡眠会引起两次两次进程上下文切换。

3. 锁保护的是数据而不是代码。

4. 调试选项 

   * CONFIG_DEBUG_SPINLOCK：内核会检查是否使用了未初始化的锁，是否在还没加锁的时候就要对锁执行开锁操作。测试阶段应该总开着
   * CONFIG_DEBUG_LOCK_ALLOC: 全程调试锁

5. 自旋锁不可递归！同一线程里尝试连续两次持有会造成死锁！自己锁死自己。

6. 自旋锁可以用在中断处理程序中，因为它不会引起其他争用处代码的睡眠。

7. **在中断中使用spin lock时，一定要先禁止本地中断（本CPU的中断），再尝试拿锁。**否则中断程序就可能在拿锁时被别的中断打断：别的或者本类中断源重复触发，导致上一次拿的锁还没释放，然后此次拿锁时就被卡住。结果就是上次拿的锁，因为此次中断没退出导致没机会放锁，而此次中断又被卡在拿锁的地方。。。噔噔，死锁。

   禁止中断同时拿锁的接口：

   ~~~c
   DEFINE_SPINLOCK(my_lock);
   unsigned long flags;
   spin_lock_irqsave(&my_lock, flags);
   /*临界区*/
   spin_lock_irqrestore(&my_lock, flags);
   ~~~



## 自旋锁和下半部

1. 对进程上下文和下半部共享的数据进行保护，**加锁的同时还需要禁止下半部执行**。因为下半部可以抢占进程上下文执行，可能会引起死锁。
2. 对中断处理程序和下半部共享的数据进行保护，**加锁的同时也需要禁止中断**。因为中断可能会断下半部的执行。
3. 因为同类tasklet不会同时运行，所以同类tasklet中共享的数据不需要保护。但是在不同类的tasklet中共享数据时，则需要保护，**不过这里用自旋锁时，不需要禁止下半部**，因为同一个CPU不会有tasklet互相抢占的情况。
4. 对于软中断，无论是否同类型，数据被软中断共享时，都必须得到锁的保护。因为即使时相同类型的软中断，也可以同时运行在一个系统的多个处理器上。但是同一个处理器上的一个软中断绝不会抢占另一个软中断，**所以也不需要禁止下半部**。



## 读--写自旋锁  rw_lock

1. 一个或多个读任务可以并发地持有read lock；但 write lock 最多只能被一个写任务持有，且在 write lock 被持有的情况下，不能有并发的读操作。

2. 通常情况下，read lock 和 write lock 位于完全分割的代码中。不能把一个 read lock “升级” 为  write lock，如下会造成**死锁**：

   ~~~c
   DEFINE_RWLOCK(rwlock);
   
   read_lock(&rwlock);
   write_lock(&rwlock);
   ~~~

3. 如果进程上下文和中断中会用到同一个读写锁，则进程上下文中需要使用如下接口持有读写锁：

   ```c
   write_lock_irqsave();
   /*临界区*/
   write_lock_irqrestore();
   ```

   这样在拿锁的时候会把中断禁止掉，否则会造成**死锁**。

   *考虑一下：进程中已经持锁，并正在进行写操作，此时中断发生，尝试拿同一个write lock，会拿不到，然后自旋，而进程里因为中断不退出而不会继续执行，所以死锁了。*

4. 读写锁更多地是照顾读操作，大量地读者会造成写操作处于饥饿状态。



## 信号量

1. 自旋锁保护的临界区内不能申请信号量，因为信号量可能会引起睡眠，进而导致别的申请锁的CPU自旋。
2. 使用 **down_interruptible()** 获取信号量，信号不可用时，进程进入 TASK_INTERRUPTIBLE 状态。而 **down()**则会使进程进入TASK_UNINTERRUPTIBLE状态。因此使用  **down_interruptible()** 比 **down()**更普遍。
3. **down_trylock()**拿到信号量时返回0， 拿不到时返回非0.



## 读-写信号量

1. 和读写锁类似，只要没有写者，并发持有信号量的读者数不限。
2. **所有的读-写信号量引起的睡眠都不可打断。**所以它只有一个版本的  down() 操作。
3. **down_read_trylock()和down_write_trylock()**在拿到锁时返回非0，拿不到时返回0。
4. **downupgrade_write()**可以动态的将写锁转换为读锁。



## 互斥体

1. 当持有mutex时，进程不能退出。

2. 中断或者下半部中不能使用mutex，即使时 mutex_trylock() 也不行。

3. 调试选项 **CONFIG_DEBUG_MUTEXES** 可以让内核检测mutex的使用是否有问题。

4. 首选互斥体，不能满足时再用信号量。

5. 自旋锁和互斥体：

   | 需求           | 建议的加锁方法 |
   | -------------- | -------------- |
   | 低开销加锁     | 优先使用自旋锁 |
   | 短期锁定       | 优先使用自旋锁 |
   | 长期加锁       | 优先使用互斥体 |
   | 中断上下文加锁 | 使用自旋锁     |
   | 持有锁需要睡眠 | 使用互斥体     |



## 完成变量 completion variable

1. 如果在内核中一个任务需要发出信号通知另一个任务发生了某个特定事件，利用**完成变量**是使两个任务的得以同步的简单方法。这个和event是类似的。



## 顺序锁 seq lock

1. 在多个读者和少数写者共享一把锁的时候，seq lock有助于提供一种非常轻量级和具有可扩展性的外观。

2. 和 **读-写信号量**相反，seq lock对写者更有利：只要没有其他写者，写锁总是能够被获取成功。读者不会影响写锁。挂起的写者会使读者不断循环，直到不再有任何写者持有锁为止。

3. seq lock在读者尝试读锁时与自旋锁不大一样。

   定义：

   ~~~c
   seqlock_t seqlock = DEFINE_SEQLOCK(seq_lock);
   ~~~

   写锁：

   ~~~c
   write_seqlock(&seqlock);
   /*写数据*/
   write_sequnlock(&seqlock);
   ~~~

   读锁：

   ```c
   unsigned long seq;
   do {
       seq = read_seqbigen(&seqlock);
       /*这里读数据*/
   } while(read_seqretry(&seqlock, seq));
   ```

4. 在遇到如下需求时，seq lock是理想的选择：

   * 你的数据存在很多读者
   * 你的数据写者很少
   * 虽然写者很少，但是你希望写优先于读，而且不允许读者让写者饥饿
   * 数据很简单，如简单结果，甚至是简单的整型——特别在某些场合不能使用原子量

   *Linux中存储系统启动时间的jiffies就是使用seq lock保护的*



## 禁止内核抢占

1. 使用场景：

   当数据只有某个CPU能访问时，此时不需要自旋锁，因为不需要防止其他CPU访问。但此时又要禁止抢占，就可以通过关闭内核抢占来达到目的。

   *虽然数据只能某个CPU访问，但跑在这个CPU上的多个进程或者中断仍可能会共享该数据，所以要禁止抢占。*

   相关函数：

   | functions                   | description                                                 |
   | --------------------------- | ----------------------------------------------------------- |
   | preempt_disable()           | 增加抢占计数值，从而禁止内核抢占                            |
   | preempt_enable()            | 减少抢占计数值，当该值降为0时检查和执行被挂起的需调度的任务 |
   | preempt_enable_no_resched() | 激活内核抢占但不在检查任何被挂起的需调度任务                |
   | preempt_count()             | 返回抢占计数值                                              |

   

## 内存屏障

| 函数      | 描述                 |
| --------- | -------------------- |
| mb()      | 读写屏障             |
| rmb()     | 读屏障               |
| wmb()     | 写屏障               |
| __iormb() | 作用于寄存器的读屏障 |
| __iowmb() | 作用于寄存器的写屏障 |
| barrier() | 编译屏障             |

